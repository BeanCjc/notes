# 网络知识
## 1 提纲

### 1.1 什么是Internet

层次性结构是网络结构的基础，下层为上层提供服务，上层完善整个网络结构
应用层交换应用报文，实现各种各样的应用。http协议、ftp协议等各种协议
传输层完成进程到进程的可靠传输，传输tcp/udp协议报文
网络层完成端到端（主机到主机）的不可靠传输，传输ip数据报（ip协议），路由器（R），防火墙
数据链路层完成点到点（比如交换机到交换机等）的传输，传输帧，网卡、交换机（sw）
物理层将0、1数据和物理信号（光信号、电信号等）之间相互转换并传输

从构成的角度来说，互联网：节点和边
节点：主机节点、数据交换节点（中继器、交换机、路由器）
边：接入的链路、骨干链路、协议
协议：对等层的实体，在通信的过程中应该遵守的规则的集合，协议定义了在两个或多个通信实体之间交换的报文格式（语法、语义）和次序，以及在报文传输或接收或其他事件方面所采取的动作

从服务的角度来说，互联网可以是分布式应用进程和为分布式应用提供通信的基础设施（应用层以下所有）
基础设施通过面向连接的可靠服务或者面向无连接的不可靠服务对外（应用）提供服务

### 1.2 网络边缘

### 1.3 网络核心

两种数据传输方式：线路交换和分组交换

### 1.4 接入网和物理媒介

### 1.5 Internet结构和ISP（Internet Service Providers）

### 1.6 分组延时、丢失和吞吐量

延时：排队延时、处理延时（查路由表）（微妙级甚至更少）、传输延时（带宽）（微秒级到毫秒级）、传播延时（距离）（几微秒到击败毫秒 ）

两个路由之间称为一跳（hop）

TTL（生存时间）：Time To Live

RTT（往返时间）：Round Trip Time

丢失：链路的队列缓冲区容量有限，丢失的分组可能由上一跳重传（链路层可靠），可能由源主机重传（Tcp未收到应答信号），也可能不重传（UDP）

吞吐量：在源端和目标端之间传输的速率，数据量/单位时间，源端发出到目标端接收到有效的数据，吞吐量的大小取决于网络核心中有效带宽（链路可能同时被多个链接使用）最小的那一跳

瞬时吞吐量：在一个时间点的速率

平均吞吐量：在一个长时间内平均值

### 1.7 协议层次和服务模型

层次化方式实现复杂的计算机网络
每层通过层间接口向上层提供服务，实现更复杂的服务，最终实现计算机网络，层的目的是向上层提供更好的服务，层的实现是通过层间接口调用下层提供的服务。

服务：低层实体向上层实体提供他们之间的通信的能力

- 服务用户
- 服务提供者

原语（primitive）：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行监护的---形式

服务访问点SAP（Service Access Point）：上层使用低层服务时，低层服务区分上层服务（上层使用下层提供的服务通过层间的接口--地点）

数据单元（DU：Data Unit）

服务数据单元（SDU：Service Data Unit）

协议数据单元（PDU：Protocol Data Unit）

本层的接口控制信息（ICI：Interface Control Information）

每层的PDU称呼都不同
应用层叫应用报文（message），传输层叫报文段（segment），网络层叫分组（packet）/IP数据报（datagram）、数据链路层叫帧（frame），物理层叫位（bit）

Internet协议栈

- 应用层：网络应用，FTP、SMTP、HTTP、DNS
- 传输层：跨主机间进程传输，TCP、UDP
- 网络层：主机间的通信，端到端的通信，不可靠，IP协议、路由协议
- 链路层：相邻网络节点间的数据传输，点到点通信，点对点协议PPP、802.11（wifi），Ethernet
- 物理层：在线路上传送bit



## 2 应用层

### 2.1 应用层协议原理

寻址：协议（TCP/UDP）、IP、端口

传输层和应用层如何传输数据

进程间使用传输层的服务，实现应用进程的协议

tcp socket指的是会话关系，包含源IP、源端口、目的IP和目的端口，传输报文时发送socket标识、数据

udp socket包含本地IP，本地端口，传输报文时发送socket标识、目的IP、目的端口、数据

### 2.2 Web and Http

URL格式：protocol://user:password@hostname/route:port
协议名 用户：口令 主机名 路径名 端口

HTTP：超文本传输协议，是无状态协议，默认端口80
HTTP 1.0：RFC 1945
HTTP 1.1：RFC 2068
http1.0使用非持久连接，http1.1默认使用持久连接，多个对象可以在一个tcp连接上传输	

http报文类型：请求，响应

http请求报文：
- 请求行（get、post、head等，http1.1还增加put、delete等）：method url protocolVersion
- 首部行
- 换行回车符（表示报文结束）
- 实体数据

http响应报文：

- 状态行：protocolVersion statusCode statusCodeDescription
- 首部行
- 换行回车符
- 实体数据

cookie：维护状态，客户端第一次请求时，服务端在响应头中写入cookie并保存在服务端，客户端将响应的cookie保存；第二次客户端请求时，带上这些cookie，此时服务端就能收到客户端发过来的cookie

### 2.3 FTP

FTP：文件传输协议，RFC959，服务端默认端口21（带外传送命令），客户端默认端口20（带内传输数据），有状态协议

### 2.4 Email

三个主要组成部分：

- 用户代理，一般是客户端软件，比如outlook，foxmail
- 邮件服务器
- 简单邮件传输协议SMTP（发送的协议），POP3（Post Office Protocol）、IMAP（Internet mail access protocol）、http等（拉取的协议）

SMTP：简单邮件传输协议，RFC2821，服务端默认端口25，使用持久连接
直接传输：从发送方邮件服务器发送到目标邮件服务器
传输过程：

- tcp建立，握手

- 传输报文
- 关闭连接

报文为7位ASCII码

报文格式：

- 首部行，To、From、Subject、cc（抄送）
- 换行回车符
- 主体，报文，只能是ASCII

报文格式：多媒体编码

MIME（multimedia mail extension），RFC 2045，2056

整体的流程是：发送方用户代理通过SMTP推送-->发送方邮件服务器，再通过SMTP推送-->接收方邮件服务器-->接收方用户代理通过POP3/IMAP拉取邮件

IMAP协议更丰富，更复杂

### 2.5 DNS

DNS：域名解析服务，域名到IP的解析服务

DNS的主要思路：

- 分层的、基于域的命名方式
- 若干分布式的数据库完成名字到IP的解析
- 运行在UDP之上端口号为53的应用服务
- 核心的Internet功能，但不是在网络核心内实现的，而是在网络边缘以应用层协议实现

DNS主要目的：

- 实现主机名-IP地址的转换
- 主机别名到规范名字的转换，host aliasing
- 邮件服务器别名到邮件服务器正规名字的转换，Mail server aliasing
- 负载均衡：Load Distribution

DNS命名结构：采用层次树状结构命名
几百个顶级域（top level domains）：

- 通用的：.com .edu .cn .gov .net .mil .org .firm .hsop .web .arts .rec等
- 国家的：.cn .us .nl .jp

每个域下可划分为若干个子域（subdomains），树叶是主机名

13个根名字服务器

资源记录RR，存在DNS服务器的数据库中，每条数据包含Domain、TTL、class、value、type，class为类别，本地缓存ttl默认为2天，对于Internet值为IN。RR格式：（dimain_name, ttl, type, class, value）

- type=A
  - dimain_name为域名
  - value为IP地址
- type=CNAME
  - dimain_name为规范名字的别名
  - value为规范名字
- type=NS
  - dimain_name为域名（子域的名字）
  - value为该域名的权威服务器的域名（子域DNS服务器的域名）
- type=MX
  - dimain_name为邮件服务器的别名
  - value为邮件服务器的规范名字

DNS解析过程：

- 客户端调用解析器
- 解析器向本地DNS服务器发出查询
- DNS服务器返回响应报文

### 2.6 P2P应用

peer to peer

- 非结构化P2P
  - 集中化目录，存在单点故障、性能瓶颈、版权等问题
  - 完全分布式：所有节点构建出一个覆盖网（overlay），所有节点都一样，没有中心服务器
  - 混合体，上述两种的混合，以组和组员的形式实现
- DHT（结构化）P2P

防洪（flooding）：我向我的所有邻居发出查询，我的所有邻居也向他们的所有邻居（除了我）发出查询，以此类推，然后反向返回，以此达到向所有用户发出查询的一个目的

### 2.7 CDN

CDN（Content Distribution Networks）：内容分发网络，内容加速服务

视频的原理：由于视网膜存在滞留效应，看过某个图像后要过个几十毫秒才会消失，视频由一个个的图像构成的。
帧：表示每秒播放的图像数，例如24帧、60帧等
视频占据大量的带宽，在互联网中传输一般会采取压缩（空间压缩、时间压缩）。

CBR（constant bit rate）：以固定速率编码

VBR（variable bit rate）：视频编码率随时间的变化而变化

视频编码：AVS、MPEG1（CD-ROM）1.5Mbps、MPEG2（DVD）3-6Mbps、MPEG4（often used in internet， <1Mbps）

存储视频的流化服务：边下边播，缓冲区内的即可播放

DASH（Dynamic Adaptive Streaming over http）：多媒体流化服务
服务器：

- 将视频分割成多个块（假设每块为8-10秒的长度大小）

- 每个块独立存储，编码于不同码率（8-10种）

- 告示文件（manifest file）：提供不同块的url

客户端：

- 先获取告示文件
- 周期性的测量服务器到客户端的带宽
- 查询告示文件，在一个时刻请求一个块，http头部指定字节范围
  - 如果带宽足够，选择最大码率的视频块
  - 会话中的不同时刻，可以切换请求不同的编码块（取决于当时的可用带宽）
  - 客户端设备需求、缓冲区大小也会决定请求的文件

**对于服务器如何通过网络向上百万用户同时流化视频内容？**

**方案一**：采用单个的、大的超级服务中心“mega-server”，该方案简单，但同时存在以下一些问题：

- 客户端向服务器请求有很多跳，链路瓶颈
- 二八定律：网络中充斥着同一个视频的多个拷贝，重复流量
- 单点故障，性能瓶颈
- 周边网络拥挤

**方案二**：通过CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验。通过域名解析重定向，可以向最近的服务器请求资源，减少链路跳数。一般有两种缓冲位置的设置：

- enter deep：将CDN服务器深入到如多接入网
  - 离用户最近，相应最快，链路跳数极少
  - 部署节点繁多，管理困难
- bring home：部署在少数（10个左右）关键位置，链路跳数稍微多一些，也能起到加速左右，同时只需部署几个节点即可

中国的CDN服务提供商有：中国蓝汛（ChinaCache）

CDN一般流程为：

- 内容制作、内容分发（视频上传到各个CDN缓冲节点）
- 用户点击内容url（视频地址）
- DNS解析重定向至离用户最近的CDN节点
- 下载并播放视频

### 2.8 TCP套接字编程

应用进程使用传输层提供的服务才能够交换报文，实现应用协议，实现应用

- TCP/IP：应用进程使用Socket API访问传输层服务
- 地点：界面上的SAP（Socket）方式：Socket API

2种传输层服务的socket类型：

- TCP：可靠的、字节流的服务
- UDP：不可靠（数据UDP数据报）服务

套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户

TCP服务：从一个进程向另一个进程可靠的传输字节流

工作过程：

- 服务器首先运行，等待连接建立

  - 创建welcome socket，返回一个整数（句柄/socket id） `socket.create`
  - 和本地IP、端口捆绑 `socket.bind(ip, port)`
  - 在welcome socket上阻塞式等待接受用户的连接 `socket.accept()`

- 客户端主动和服务器建立连接

  - 创建客户点本地套接字（隐式捆绑到本地port） `socket.create`，指定服务器进程的IP地址和端口，与服务器进程连接`socket.connect`
  - 当客户端连接请求到来时，服务器接受来自客户端的请求，接触阻塞式等待，返回一个新的connect socket（与welcome socket不一样），与客户端通信
    - 允许服务器与多个客户端通信
    - 使用源IP和源端口来区分不同的客户端
  - 连接API调用有效时，客户端与服务器建立了TCP连接

  从应用程序的角度来看：TCP在客户端和服务器进程之间提供了可靠的】字节流（管道）服务。

示例：客户端将标准输入的小写字符，通过socket，服务器将字符串转换成大写并返回给客户端

```c
struct sockaddr_in {
  short sin_family; //AF_INET，地址族，标识是TCP还是UDP
  u_short sin_port; //port，端口号
  struct in_addr sin_addr; //IP address,unsigned long
  char sin_zero[8]; //align，对齐
}
```

```c
struct hostent {
  char *h_name; //指针，主机域名
  char **h_aliases; //指针的指针，二维的，主机一系列的别名
  int h_addrtype; //
  int h_length; //地址长度，32位或其他
  char **h_addr_list; //IP地址列表
  #define h_addr h_addr_list[0]
}
//作为调用域名解析函数时的调用，输入域名，得到IP地址，将得到的IP地址拷贝到sockaddr_in的IP地址部分
```

```c
//服务器，建立welcome socket
//create socket port=x
//for incomming request
//1.welcomSocket = Socket()，返回一个数字，假设位8888
//2.bind(welcomeSocket, &sad),sad是结构体sockaddr_in，绑定本地IP和端口，假设此处服务器守护在1.1.1.1:80，客户端守护在2.2.2.2:777
//3.conncetSocket=accept(welcomeSocket)

//客户端，创建socket
//4.clientSocket = Socket()，返回一个数字，假设位2222
//5.bind(clientSocket, &cad)，cad是结构体sockaddr_in
//6.connect(clientSocket, &sad)，sad指明了服务器端的IP和port
//7.服务器返回一个应答，服务器端accept解除阻塞，同时返回一个整数（假设为8899）；此时connect返回一个有效值，clientSocket才是有效的
//8.write(clientSocket, data)
//9.服务端read(connetSocket)，返回data
//10.小写转大写并发给client，write(connectSocket)
//11.客户端read(clientSocket)
//12.服务端close(connectSocket)
//13.客户端close(clientSocket)
```

### 2.9 UDP Socket编程

UDP：在客户端和服务器之间没有连接

- 没有握手
- 发送端在每一个报文中明确地指定目标IP和port
- 服务器必须从接收到的分组中提取出发送端地IP和port

UDP：传送地数据可能乱序，也可能丢失

进程角度看UDP服务：UDP为客户端和服务器提供不可靠的字节组的传送服务



## 3 传输层

### 3.1 概述和传输层服务

传输层的工作原理：

- 多路复用/解复用
- 可靠数据传输（RDT：Reliable Data Transfer）
- 流量控制，接收方能否接收这么快的传输速度
- 拥塞控制，网络拥堵控制

传输层为上层（应用层）提供的服务是进程与进程之间的，以message为单位的逻辑通信；向下层（网络层）以段为单位进行传递数据

传输层提供的协议有TCP和UDP。

网络层提供的服务是不可靠的，TCP加强了其可靠性，有数据丢失、乱序、延迟、出错等。有的特性能加强，有的不能加强，延时和带宽问题无法加强。TCP提供可靠、保序的服务

### 3.2 多路复用和解复用

发送方主机多路复用：
从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装（该头部信息用于以后的解复用）

接收方主机多路解复用：
根据报文段的头部信息中的IP和端口将接收到的报文段发给正确的套接字（和对应的应用程序）

### 3.3 无连接传输UDP

UDP（User Datagram Protocol）：用户数据报协议，在网络层之上没有做太多的扩展，数据报可能丢失、乱序
一般用于流媒体、DNS、SNMP等

UDP数据报的格式：

- 8个字节头部（Head），32比特；两个字节源端口，两个字节目标端口，两个字节数据长度（整个UDP报文的长度，包括头部，以字节为单位），两个字节校验和
- 报文（Payload）

EDC（Error Detection Code）：差错检测码

校验和（Check Sum）：

- 发送方

  将报文段的内容以16比特为长度进行切割并相加再进行进位取反（最高位的进位回卷）；校验和：报文段的加法和（1的补运算）；发送方将校验和放在UDP头部的校验和字段

- 接收方

  计算接收到的报文段的校验和，检查计算出的校验和与传过来的校验和的内容是否相等

残存错误：发送方计算得到的校验和与接收方计算得到的校验和不一致一定错，反之，两者一致时不一定对

发送方的校验和+接收方的校验和=FFFF，说明是对的

下面假设报文段的二进制为刚好32比特长度 1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1，进行发送方校验和计算

   1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0
   1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1

----

1 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 1    第一步 此时最高位溢出了一位1，回加到当前和上
   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1

----

   1 0 1 1 1 0 1 1 1 0 1 1 1 1 0 0    第二步 和

----

   0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1     第三步将得到的和进行取反得到的就是发送方的校验和

接收方的校验和只做到第二步，此时两个校验和加起来为FFFF

### 3.4 可靠数据传输（RDT）的原理

停止等待协议（stop  and wait）

FSM（Finite State Machine）：有限状态机

检错重传

超时重传，发出一个packet后，定时等待ack，指定时间没收到ack，则重传。传输层和数据链路层设置超时时间的方式不同

流水线协议（pipeline protocol）：允许发送方在**未得到对方确认**的情况下一次发多个分组，必须增加需要的范围，用多个bit标识分组的序号，发送方和接收方需要有缓冲区
两种通用的流水线协议：回退N步（GBN：Go Back N）和选择重传（SR：Selective Repeat），SR可以乱序接收

滑动窗口协议（slide window），发送窗口（SW：Sending Window），接受窗口（RW：Receiving Window）

| 发送窗口大小 | 接收窗口大小 |        协议         |
| :----------: | :----------: | :-----------------: |
|     SW=1     |     RW=1     | S-W（停止等待协议） |
|     SW>1     |     RW=1     |         GBN         |
|     SW>1     |     RW>1     |         SR          |



### 3.5 面向连接的传输：TCP

TCP概述：RFC 793、1122、1323、2018、2581

- 点对点（进程到进程）：一个发送方一个接收方
- 可靠的、有序的字节流
- 管道化（流水线）：TCP拥塞控制和流量控制设置窗口大小
- 发送和接收缓存
- 全双工数据，在同一个连接中数据流双向流动，MSS：最大报文段大小
- 面向连接：在数据交换之前，通过握手（交换控制报文）初始发送方、接收方的状态变量
- 流量控制：发送方不会淹没接收方

MTU：最大传输单元，以太网最大MTU为1500Byte

MSS加上TCP的头部（20字节），传递到IP层再加上IP的头部（20字节），刚好封装到物理网络的MTU中

TCP报文段结构：

- 16比特（bit）源端口号，16比特目标端口号
- 32比特的序号（sequence，seq），以字节为编号，应用层的字节流按照MSS切分的偏移量
- 32比特的确认号（ack序号），以字节为单位，RDT中的分组序号，假设接收方发送ack=555，表示接收方已收到555之前的所有数据，发送方此时需要发送序号为555的分组数组
- 首部长度，保留未用，U，A，P，R，S，F，接收窗口（用于流量控制，表示接收方可接收的流量大小）
- 校验和（同UDP），紧急数据指针（已经不用了）
- 可选项
- 应用层数据，长度可变

超时定时器的设置：RTT采样的移动平均值+4倍的移动平均值的偏差
TimeoutInterval = EstimatedRTT + 4*DevRTT

TCP是GBN、SR的混合体

快速重传：三个冗余的ack（加上正常的一个ack算上就是四个ack）触发重传报文段，而不是等待超时定时器超时触发重传报文段

流量控制原理：接收方将自己空闲的缓冲区大小通过头部信息（接收窗口）传递给发送方，以此达到流量控制的目的

piggybacking：捎带

TCP连接管理：在正式交换数据之前，发送方和接收方握手建立关系，准备资源（准备缓冲区），初始化控制变量，告诉双方的初始序号等

连接建立三次握手：

- 客户端连接请求，标志位1（SYN=1），告诉对方自身的seq，假设为x
- 服务器连接确认ack=x+1，告诉对方自己的seq，假设为y
- 客户端确认ack=y+1

两次连接可能造成

- 服务器维持虚假的连接，或者说是服务器维持TCP连接，客户端却不维持TCP连接
- 导致服务器接收过时的数据

三次连接是由于需要确认双方选择的初始序号（seq），避免两次连接造成的问题。交换随机seq是为了避免网络中的干扰

取时钟周期的低32位作为seq，可降低先后多个TCP连接造成seq相同的情况

连接断开/四次挥手
双向断开，停止数据传输。对称释放，并不完美

- 客户端发起断开连接请求，控制报文Fin=1，同时不再发送数据，但可以接收数据
- 服务端ack，继续发送剩余的数据段
- 服务端发送完剩余的数据后，发送控制报文Fin=1，断开服务器端的TCP连接
- 客户端ack，此时不再接收数据

最后再启用一个定时器，在定时器周期内不再接收到数据，即表示该连接被关闭

### 3.6 拥塞控制原理

拥塞指的是太多的数据需要网络传输，超过了网络的处理能力，网络拥塞不加以控制可能会恶化直至瘫痪。一般表现为：

- 分组丢失
- 分组延迟

拥塞的原因：

- 大量的网络请求，超过网络带宽大小
- 路由器缓冲区没满，但滞留数据较多，发送端发触发超时重传，此时这些数据是重复的，没必要重传，因此也加剧了拥塞程度
- 路由器缓冲区满了，数据丢弃，发送端超时重传
- 较差的网络拓扑，在拥塞时数据在网络下游被抛弃，加剧网络拥塞，甚至瘫痪

拥塞控制方法：

- 端到端的拥塞控制。没有来自网络的显示反馈，端系统根据延迟和丢失时间推断是否拥塞，TCP就是采用这种方法
- 网络辅助的拥塞控制。路由器提供给端系统以返回信息，单个bit置位，显示有拥塞（SNA，DECbit，TCP/IP ECN，ATM），显示提供发送端可以采用的速率

ATM网络拥塞控制：发送端发送信元（53bit），网络中会怎么增加资源管理信元（RM）， 设置相应的控制位，到达接收端后，反馈给发送端，发送就就可以采取相应的减速行为

### 3.7 TCP拥塞控制

端到端的拥塞控制，减轻网络交换节点的负担

控制机制：路由器不向主机提供拥塞的反馈信息。端系统根据自身得到的信息判断是否发生拥塞，从而采取动作。

拥塞控制的几个问题：

1. 如何检测？拥塞程度？
2. 控制策略？如何降速？如何提速？

如何检测：

1. 超时丢失，网络拥塞（缓冲区满了，丢弃），大概率原因；出错丢弃（经过某些路由器或交换机等时发生错误，没有通过校验）。可能误判，但总体方向是对的
2. 某个段收到重复3次的ack，判定为轻度拥塞

如何控制：

Rate=CongWin/RTT bytes/sec进行粗略测量，ConggWin为拥塞控制窗口，已发送未确认的数据量；

- 超时或3个重复ack时，减小CongWin
  - 超时时：CongWin将为1MSS，进入慢启动阶段（SS，slow start阶段）后，每个RTT成倍增加CongWin，从而进入拥塞避免阶段（CA，congestion avoidance阶段），从此按照线性增加CongWin
  - 3个重复ack时，CongWin降为CongWin/2，CA阶段
- 否则（正常收到ack，无上述以上两种情况）CongWin增加：
  - SS阶段：每个RTT成倍增加CongWin，指数增加
  - CA阶段：每个RTT增加CongWin，线性增加

拥塞控制和流量控制是同时作用的，发送窗口
$$
SendWin=min(CongWin, RecvWin)
$$
RecvWin为接收方缓冲区空闲的大小（字节）

连接刚建立时CongWin=1MSS，例如MSS=1460bytes并且RTT=200ms，测初始速率
$$
RateInit=1460/200=1460*8/1000/0.2=58.4kbps
$$
当连接开始时，指数性增加：每个RTT的CongWin为上一个RTT的CongWin的2倍，直到发生丢失事件

TCP拥塞控制总结：

Threshold：阈值

- 当CongWin<Threshold时，发送端出于SS（slow-start）阶段，CongWin指数增长
- 当CongWin>Threshold，发送端出于CA（congestion-avoidance）阶段，CongWin线性增长
- 当收到3个重复ack时，Threshold设置为CongWin/2，CongWin=Threshold+3
- 当发生超时事件时，Threshold=CongWin/2，CongWin=1MSS，进入SS阶段

